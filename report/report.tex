\documentclass[a4paper]{article}

% HEADER
\input{header_report.tex}


\begin{document}

% ==================================================================================================================================
% TITLE 

% \input{titlepage_report.tex}

\begin{center}
    {\scshape {Algorithmique Avancée}} \par \vspace{0.5em}
    {\Large \textbf{Projet 2 : Tournoi de combats}}
\end{center}

\vspace{0.5cm}

\raggedright
Axel PIGEON -- \href{mailto:axel.pigeon@univ-tlse3.fr}{axel.pigeon@univ-tlse3.fr}

\begin{center}
    \begin{minipage}{0.9\textwidth}
        \small
        \itshape
        \hrule
        \vspace{0.3cm}
        \textbf{Contexte --- } Ce projet porte sur la résolution d'un problème d'optimisation combinatoire appliqué à 
        l'organisation d'un tournoi de combats. L'objectif est de maximiser le gain net d'une équipe de combattants 
        opposée à une équipe d'hôtes, sous des contraintes strictes de ressources et de capacités. Le modèle intègre 
        une gestion de budget énergétique global, des pénalités pour les combats évités, ainsi que des mécanismes 
        stratégiques tels que la désignation d'un capitaine (bénéficiant d'un bonus de compétence) ou l'usage d'une 
        carte "Joker" (doublant les enjeux). 
        
        La problématique réside dans l'appariement optimal des duels, où chaque combattant dispose d'un nombre limité 
        d'actions et chaque hôte possède des valeurs de profit et de perte distinctes. Ce rapport détaille l'approche 
        algorithmique choisie, les structures de données mises en œuvre pour traiter les instances du problème, ainsi 
        que l'analyse de la complexité de notre solution face à l'explosion des combinaisons possibles.
        \vspace{0.3cm}
        \hrule
    \end{minipage}
\end{center}


% ==================================================================================================================================
% Introduction 

\justify
\subsection*{Introduction}

Nous détaillons ici deux méthodes utilisées pour la résolution de différentes instances de ce problème contenant respectivement 
6, 20 et 100 combattants. Nous nous intéressons d'abord à la résolution grâce au solveur SCIP en modélisant le problème sous 
forme de Programme Linéaire en Nombres Entiers. Cette approche nous permettra d'obtenir des solutions optimales. 
Dans un second temps, nous nous intéresserons à une approche heuristique. L'idée sera ici de déterminer une solution proche 
de l'optimal grâce à une marche aléatoire type recuit simulé sur l'ensemble des solutions.
L'ensemble du code est disponible sur le Github : 
    \begin{center}
        \href{https://github.com/winston2968/Combinatorial-Optimization.git}{https://github.com/winston2968/Combinatorial-Optimization.git}
    \end{center}

% ==================================================================================================================================
% Programmation en nombres entiers

\section{Programmation en nombres entiers}

Pour résoudre le problème de manière exacte, nous avons modélisé le tournoi sous la forme d'un \emph{Programme Linéaire en Nombres 
Entiers (PLNE)}. Cette approche garantit l'obtention de l'optimum global pour les instances de taille raisonnable en explorant 
l'ensemble des solutions possibles via l'algorithme de \textit{Branch-and-Bound}. La version du problème résolut ici 
est celle comportant les rôles de Capitaine et de Joker. 

\paragraph{Variables de décision.}
Le modèle repose sur une matrice de variables binaires $x_{i,j}$ telle que :
\begin{itemize}
    \item $x_{i,j} = 1$ si le combattant $i$ affronte l'hôte $j$, $0$ sinon.
    \item $c_i \in \{0, 1\}$ : variable binaire indiquant si le combattant $i$ est désigné Capitaine.
    \item $j_i \in \{0, 1\}$ : variable binaire indiquant si le combattant $i$ possède le Joker.
\end{itemize}
La matrice $(g_{i,j})$ représente le gain brut de chaque combat calculé en amont de la résolution. 

\paragraph{Objectif et Linéarisation.}
L'objectif est de maximiser le gain net, incluant les bonus du Capitaine ($+5$ en compétence) et du Joker ($\times 2$ sur les gains et pertes). Pour conserver un modèle linéaire, nous avons utilisé des variables de couplage $actCap_{i,j}$ et $actJok_{i,j}$ pour représenter l'activation des bonus lors d'un combat spécifique.
L'objectif s'écrit alors :
\begin{equation}
    \max \left( \sum_{i,j} \left(g_{i,j} \cdot x_{i,j} + \Delta Cap_{i,j} \cdot actCap_{i,j} + \Delta Jok_{i,j} \cdot actJok_{i,j}\right) - P \cdot \left(n - \sum_{i,j} x_{i,j}\right) \right)
\end{equation}
Où $\Delta Cap$ et $\Delta Jok$ représentent les gains incrémentaux apportés par les bonus respectifs et $P$ 
est la pénalité déduite pour chacun des $n$ hôtes non combattu.

\paragraph{Contraintes.}
Les contraintes du modèle assurent la validité de la solution :
\begin{itemize}
    \item \emph{Capacité des combattants :} $\sum_{j=1}^{n} x_{i,j} \leqslant 2 - c_i$. Un combattant normal effectue au plus 2 combats, le capitaine au plus 1.
    \item \emph{Unicité de l'hôte :} $\sum_{i=1}^{p} x_{i,j} \leqslant 1$. Chaque hôte ne peut être combattu qu'une seule fois.
    \item \emph{Budget énergétique :} $\sum_{j=1}^{n} E_j \cdot (\sum_{i=1}^{p} x_{i,j}) \leqslant B$.
    \item \emph{Rôles uniques :} $\sum_{i} c_i \leqslant 1$ et $\sum_{i} j_i \leqslant 1$.
\end{itemize}

\paragraph{Optimisations pour les grandes instances.}
Pour l'instance \texttt{tournament\_100.txt}, le nombre de variables binaires dépasse les 20 000. Pour réduire le temps de calcul, nous avons implémenté :
\begin{enumerate}
    \item \emph{Priorités de branchement :} Nous avons forcé le solveur à brancher en priorité sur les variables $c_i$ et $j_i$ (\texttt{chgVarBranchPriority}), car le choix des rôles structure fortement le reste de la solution.
    \item \emph{Relâchement de la précision :} L'acceptation d'une précision d'optimalité de 5\% permet d'obtenir une solution de haute qualité en quelques secondes là où l'optimum exact requerrait plusieurs heures.
\end{enumerate}

% ==================================================================================================================================
% Méta-heuristique

\section{Méta-heuristique}

Dans cette section, nous essayons d'approcher une solution optimale au problème sous la forme d'une 
méta-heuristique. Contrairement à la recherche exhaustive précédente, nous n'essayons pas de considérer 
toutes les solutions possibles, nous simulons plutôt une marche aléatoire sur l'ensemble des solutions 
en essayant de trouver un maximum. 
Pour cela, nous devons définir plusieurs notions telles que le \emph{voisinage} d'une solution, sa \emph{valeur} 
ainsi que sa \emph{validité}. Comme précédemment, le choix des structures de données sera déterminant pour réduire 
le temps de calcul et pouvoir traiter de grosses instances. 

\paragraph{Structures de données.}
Commençons par introduire les structures de données utilisées pour modéliser le problème. L'objectif est 
de trouver une combinaison de combats qui maximise les gains de l'équipe des combattants. On doit donc affecter
à chacun des $p$ combattants un ou plusieurs des $n$ hôtes. Pour chaque solution possible, nous devons être capables d'évaluer sa 
valeur très rapidement. Il nous semble donc judicieux de vectoriser toutes les données du problème pour n'avoir qu'à effectuer 
des produits matriciels pour l'évaluation et la vérification. Nous avons donc : 

\begin{itemize} 
    \item $C$ : La matrice représentant une solution au problème telle que $(i,j) = 1$ ssi le combattant $i$ affronte 
    l'hôte $j$ et $0$ sinon.
    \item $E$ : Un vecteur qui représente l'énergie nécessaire pour combattre chacun des $n$ hôtes.
    \item $W$ : Une matrice représentant le gain possible de chaque combat, $(i,j) = W_j$ si le combattant $i$ bat 
    l'hôte $j$ lors d'un combat. 
    \item $L$ : Une matrice représentant la perte de possible de chaque combat, $(i,j) = L_j$ si le combattant $i$ 
    est battu par l'hôte $j$. 
    \item $M$ : La matrice des gains bruts pour chaque combat possible. 
\end{itemize}

$M$ se calcule très simplement par $ M = W - L$. 
On remarque donc que pour évaluer le gain brut d'un combat (sans pénalités), il suffit d'évaluer : 
    $$ \sum_{j=1}^{n} \sum_{i=1}^{p} C \odot M $$ 
où $\odot$ est la multiplication termes à termes des deux matrices. On a donc : 
    \begin{align}
        Tr (^t C M)_{i,j} = \sum_{j=1}^{n} \sum_{i=1}^{p} C_{i,j} M_{i,j} = \sum_{j=1}^{n} \sum_{i=1}^{p} C \odot M
    \end{align}
D'autre part, pour calculer le coût total en énergie $E_\text{totale}$ d'une configuration $C$, il suffit aussi d'effectuer :
    \begin{equation}
        E_\text{totale} = \; ^t 1_p (C \times E).
    \end{equation}
Nous effectuons ce calcul grâce à la fonction \texttt{get\_energy\_value}.
Enfin, pour déterminer la valeur de la pénalité à soustraire au gain de chaque configuration, nous devons 
compter le nombre d'attaquants combattus par hôtes. Soit $P$ la pénalité définie par l'instance, on a donc :
    \begin{equation}
        P_{totale} = P \times \left(n - \sum_{j=1}^{n} \max_i C_{i,j}\right)
    \end{equation}
Finalement, le gain net $V$ d'une configuration peut être calculé par la formule suivante : 
    \begin{equation}
        V = Tr(^t C M) - P \times \left(n - \sum_{j=1}^{n} \max_i C_{i,j}\right)
    \end{equation}
Ce calcul est effectué dans \texttt{get\_sol\_value}. La bibliothèque \texttt{numpy} est utilisée pour tous 
les calculs matriciels et les opérations de recherche sur les lignes/colonnes de la matrice $C$. 
L'intérêt de cette approche est que les matrices encodant les données du problème sont calculées à l'initialisation 
de celui-ci et seuls quelques produits matriciels sont utilisés pour l'évaluation. Cependant, pour de très grosses instances 
du problème, le stockaque de $M$ et $E$ peuvent s'avérer plus contraignant. 

\paragraph{Capitaine et Joker.}
Grâce aux structures de données utilisées, l'implémentation du Capitaine et du Joker ne requièrent pas beaucoup de 
modifications. Le Joker assigné à un combattant double les gains/pertes de tous ses combats. Il suffit donc de 
multiplier par $2$ la ligne de $M$ correspondant au combattant choisit. Cela se traduira par l'ajout d'un masque 
$J$ à l'évaluation de la solution. 
De même pour le capitaine, lors de la construction des matrices $W$ et $L$, il suffit d'additionner $5$ au niveau de 
compétence du capitaine choisi. 

\paragraph{Voisinnages.}
Passons maintenant à la définition du voisinnage d'une solution $C$. Trois types de pas ont été implémentés :

\begin{itemize}
    \item \emph{L'échange d'hôte} (\texttt{moove\_swap\_host}) : qui consiste à changer l'hôte combattu par un hôte non combattu pour un attaquant $i$.
    Ce pas permet de tester un combattant avec différents hôtes pour maximiser le gain.
    \item \emph{Le transfert d'hôte} (\texttt{moove\_shift\_contestant}) : qui consiste à transférer un hôte combattu à un autre combattant encore libre.  
    On libère ainsi combattants pour optimiser l'utilisation du budget. 
    \item \emph{L'ajout/la suppression de combat} (\texttt{moove\_add\_drop}) : cela permet de compléter le nombre de combats pour utiliser 
    tout le budget d'énergie possible. 
    \item \emph{Le changement de capitaine} (\texttt{move\_captain})
    \item \emph{Le changement de Joker} (\texttt{move\_joker})
\end{itemize}

À chaque itération de l'algorithme, un tirage aléatoire entre les différents types de pas est effectué dans la fonction 
\texttt{get\_neigbor}. Lors que le budget d'énergie est complètement utilisé, le tirage d'un add/drop supprimera systématiquement 
un combat. 
L'équilibrage des probabilités donne une priorité élevée au \textit{Swap} (35\%) pour stabiliser la consommation énergétique 
tout en cherchant l'optimum local, tandis que les mutations de rôles (Joker/Capitaine) sont limitées à 10\% du temps 
pour assurer la convergence de l'algorithme.

\paragraph{Types de recherche et résultats.}
Pour approcher des solutions optimales, il a été choisi d'implémenter la recherche locale de type Hill-Climbing ainsi 
que le recuit simulé.
Celui-ci permet à l'algorithme de ne pas stagner dans les optimums locaux de l'espace de recherche. 
Pour cela, nous permettons à l'algorithme d'accepter de moins bonnes solutions selon une proportion suivant une 
loi exponentielle au cours du temps. La marche aléatoire tend donc à se stabiliser sur un optimum global. 
De plus, la configuration initiale $C$ est initialisée à l'aide d'un algorithme de recherche gloutonne qui définit 
des combats dont le rapport gain/coût énergétique est maximum pour chaque hôte. Cela permet à l'algorihtme de recuit simulé 
de directement chercher un optimum sans passer beaucoup de temps à remplir la matrice. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/evolution_tournament_20_2.png}
        \caption{Courbe de convergence du Recuit Simulé (\texttt{tournament\_20.txt})}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/evolution_tournament_100_1.png}
        \caption{Courbe de convergence du Recuit Simulé (\texttt{tournament\_100.txt})}
    \end{subfigure}
\end{figure}

Les figures révèlent un comportement contre-intuitif du recuit simulé suite à l'initialisation gloutonne. On observe 
une dégradation immédiate de la valeur de la solution dans les premières itérations. 
Ce phénomène s'explique par la température initiale élevée qui favorise l'exploration au détriment de l'exploitation 
de la solution gloutonne. L'algorithme se "désengage" du maximum local trouvé par le glouton pour explorer l'espace, 
avant de converger vers un optimum global supérieur. Ainsi, si le glouton ne réduit pas le temps de convergence 
immédiat, il garantit à l'algorithme une présence dans une zone de l'espace de recherche à fort potentiel dès le 
lancement.

On remarque aussi l'efficacite de l'algorithme du recuit simulé qui est bien capable d'éviter les optima locaux 
au profit des optima globaux. 
% ==================================================================================================================================
% Conclusion

\section{Conclusion}

Pour conclure, les deux approches de résolution du problème nous ont permis de l'aborder de deux manières 
complètement différentes. L'approche PLNE nous a forcés à optimiser sa formulation. Cet effort est récompensé par 
l'obtention de solutions exactes malgré un long temps de calcul. 
L'approche heuristique, quant à elle, nous a permis de formuler le problème sous forme matricielle plus intuitive. Elle nous a permis 
d'approcher très finement les solutions exactes des différentes instances beaucoup plus rapidement. 

Le tableau ci-dessous présente les résultats obtenus pour les différentes instances en fonction de la méthode utilisée :

\begin{center}
    \renewcommand{\arraystretch}{1.3}
    \begin{tabular}{|l|c|c|c|c|}
        \hline
        \textbf{Instance} & \textbf{Méthode} & \textbf{Statut} & \textbf{Valeur} & \textbf{Temps ($\Delta t$)} \\ \hline
        \hline
        \multirow{2}{*}{\texttt{tournament\_6.txt}}  & PLNE & Optimal & 2555 & 0.27s \\ \cline{2-5} 
                                                      & MH + Glouton   & Approché  & 2550 & 0.23 \\ \hline
        \hline
        \multirow{2}{*}{\texttt{tournament\_20.txt}} & PLNE & Optimal & 8422 & 3.75s \\ \cline{2-5} 
                                                      & MH + Glouton & Approché & 8279 & 0.72s \\ \hline
        \hline
        \multirow{2}{*}{\texttt{tournament\_100.txt}} & PLNE & Optimal & 38192 & 438.79 \\ \cline{2-5} 
                                                       & MH + Glouton & Approché & 37548 & 10.54 \\ \hline
    \end{tabular}
    \captionof{table}{Comparaison des performances PLNE vs Méta-heuristique}
\end{center}




\end{document}
